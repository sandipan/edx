\newcolumntype{I}{!{\vrule width 1.5pt}}
\newlength\savedwidth
\newcommand\whline{\noalign{\global\savedwidth\arrayrulewidth
                            \global\arrayrulewidth 1.5pt}%
           \hline
           \noalign{\global\arrayrulewidth\savedwidth}}



\usepackage{ifthen}
\usepackage{colortbl}
\usepackage{array}
\usepackage{color}
\usepackage{soul}
\usepackage{amssymb}
% \usepackage[colortbl]

% ----------------------------------------------------------------

\newboolean{IsWide}
\setboolean{IsWide}{true}

% In math mode,
% \FlaTwoByTwo{A}{B}
%             {C}{D}
% creates the picture
%   / A || B \
%   | ==  == |
%   \ C || D /

\newcommand{\FlaTwoByTwo}[4]{
\left(
\begin{array}{c I c}
#1 & #2 \\ \whline
#3 & #4
\end{array}
\right)
}

\newcommand{\FlaTwoByTwoNoPar}[4]{
\begin{array}{c I c}
#1 & #2 \\ \whline
#3 & #4
\end{array}
}

\newcommand{\FlaTwoByTwoSingleLineNoPar}[4]{
\begin{array}{c | c}
#1 & #2 \\ \hline
#3 & #4
\end{array}
}

\newcommand{\FlaTwoByTwoSingleLine}[4]{
\left(
\begin{array}{c | c}
#1 & #2 \\ \hline
#3 & #4
\end{array}
\right)
}


\newcommand{\FlaTwoByTwoNoLine}[4]{
\left(
\begin{array}{c  c}
#1 & #2 \\
#3 & #4
\end{array}
\right)
}

% In math mode,
% \FlaTwoByOne{A}
%             {C}
% creates the picture
%   / A  \
%   | == |
%   \ C  /

\newcommand{\FlaTwoByOne}[2]{
\left(
\begin{array}{c}
#1 \\ \whline
#2
\end{array}
\right)
}

\newcommand{\FlaTwoByOneNoPar}[2]{
\begin{array}{c}
#1 \\ \whline
#2
\end{array}
}

% In math mode,
% \FlaTwoByOneSingleLine{A}
%                       {C}
% creates the picture
%   / A  \
%   | -- |
%   \ C  /

\newcommand{\FlaTwoByOneSingleLine}[2]{
\left(
\begin{array}{c}
#1 \\ \hline
#2
\end{array}
\right)
}

\newcommand{\FlaTwoByOneSingleLineNoPar}[2]{
\begin{array}{c}
#1 \\ \hline
#2
\end{array}
}


\newcommand{\FlaTwoByOneNoLine}[2]{
\left(
\begin{array}{c}
#1 \\
#2
\end{array}
\right)
}

% In math mode,
% \FlaOneByTwo{A}{B}
% creates the picture
%   ( A || B )

\newcommand{\FlaOneByTwo}[2]{
\left(
\begin{array}{c I c}
#1 & #2
\end{array}
\right)
}

\newcommand{\FlaOneByTwoNoPar}[2]{
\begin{array}{c I c}
#1 & #2
\end{array}
}

\newcommand{\FlaOneByTwoSingleLine}[2]{
\left(
\begin{array}{c | c}
#1 & #2
\end{array}
\right)
}

\newcommand{\FlaOneByTwoNoLine}[2]{
\left(
\begin{array}{c c}
#1 & #2
\end{array}
\right)
}

% In math mode,
% \FlaThreeByThreeTL{A}{B}{C}
%                   {D}{E}{F}
%                   {G}{H}{I}
% creates the picture
%   / A | B || C \
%   | -- ---  -- |
%   | D | E || F |
%   | ==  ==  == |
%   \ G | H || I /
% Notice: the TL means that the
% center block (E) is part of the
% TL quadrant, where quadrants are
% partitioned by the double lines.

\newcommand{\FlaThreeByThreeTL}[9]{
\left(
\begin{array}{c | c I c}
#1 & #2 & #3 \\ \hline
#4 & #5 & #6 \\ \whline
#7 & #8 & #9
\end{array}
\right)
}

% In math mode,
% \FlaThreeByThreeBR{A}{B}{C}
%                   {D}{E}{F}
%                   {G}{H}{I}
% creates the picture
%   / A || B | C \
%   | ==  ==  == |
%   | D || E | F |
%   | -- ---  -- |
%   \ G || H | I /
% Notice: the BR means that the
% center block (E) is part of the
% BR quadrant, where quadrants are
% partitioned by the double lines.

\newcommand{\FlaThreeByThreeBR}[9]{
\left(
\begin{array}{c I c | c}
#1 & #2 & #3 \\ \whline
#4 & #5 & #6 \\ \hline
#7 & #8 & #9
\end{array}
\right)
}

\newcommand{\FlaThreeByThreeSingleLine}[9]{
\left(
\begin{array}{c | c | c}
#1 & #2 & #3 \\ \hline
#4 & #5 & #6 \\ \hline
#7 & #8 & #9
\end{array}
\right)
}

\newcommand{\FlaThreeByThreeNoLine}[9]{
\left(
\begin{array}{c c c}
#1 & #2 & #3 \\
#4 & #5 & #6 \\
#7 & #8 & #9
\end{array}
\right)
}

% In math mode,
% \FlaThreeByThreeTR{A}{B}{C}
%                   {D}{E}{F}
%                   {G}{H}{I}
% creates the picture
%   / A || B | C \
%   | -- ---  -- |
%   | D || E | F |
%   | ==  ==  == |
%   \ G || H | I /
% Notice: the TR means that the
% center block (E) is part of the
% TR quadrant, where quadrants are
% partitioned by the double lines.

\newcommand{\FlaThreeByThreeTR}[9]{
\left(
\begin{array}{c I c | c}
#1 & #2 & #3 \\ \hline
#4 & #5 & #6 \\ \whline
#7 & #8 & #9
\end{array}
\right)
}


% In math mode,
% \FlaThreeByThreeBL{A}{B}{C}
%                   {D}{E}{F}
%                   {G}{H}{I}
% creates the picture
%   / A | B || C \
%   | ==  ==  == |
%   | D | E || F |
%   | -- ---  -- |
%   \ G | H || I /
% Notice: the BL means that the
% center block (E) is part of the
% BL quadrant, where quadrants are
% partitioned by the double lines.

\newcommand{\FlaThreeByThreeBL}[9]{
\left(
\begin{array}{c | c I c}
#1 & #2 & #3 \\ \whline
#4 & #5 & #6 \\ \hline
#7 & #8 & #9
\end{array}
\right)
}

% In math mode,
% \FlaOneByThreeR{A}{B}{C}
% creates the picture
%   ( A || B | C )
% Notice: the R means that the
% center block (B) is part of the
% R(ight) submatrix, where
% submatrices are % partitioned
% by the double lines.

\newcommand{\FlaOneByThreeR}[3]{
\left(
\begin{array}{c I c | c}
#1 & #2 & #3
\end{array}
\right)
}

% In math mode,
% \FlaOneByThreeL{A}{B}{C}
% creates the picture
%   ( A | B || C )
% Notice: the R means that the
% center block (B) is part of the
% R(ight) submatrix, where
% submatrices are % partitioned
% by the double lines.

\newcommand{\FlaOneByThreeL}[3]{
\left(
\begin{array}{c | c I c}
#1 & #2 & #3
\end{array}
\right)
}

% In math mode,
% \FlaThreeByOneT{A}
%                {D}
%                {G}
% creates the picture
%   / A  \
%   | == |
%   | B  |
%   | -- |
%   \ C  /
% Notice: the T means that the
% center block (C) is part of the
% T(op) submatrix where submatrices
% are % partitioned by the double
% lines.

\newcommand{\FlaThreeByOneT}[3]{
\left(
\begin{array}{c}
#1 \\ \hline
#2 \\ \whline
#3
\end{array}
\right)
}

\newcommand{\FlaThreeByOneTNoPar}[3]{
\begin{array}{c}
#1 \\ \hline
#2 \\ \whline
#3
\end{array}
}

% In math mode,
% \FlaThreeByOneB{A}
%                {D}
%                {G}
% creates the picture
%   / A  \
%   | -- |
%   | B  |
%   | == |
%   \ C  /
% Notice: the B means that the
% center block (C) is part of the
% T(op) submatrix where submatrices
% are % partitioned by the double
% lines.

\newcommand{\FlaThreeByOneB}[3]{
\left(
\begin{array}{c}
#1 \\ \whline
#2 \\ \hline
#3
\end{array}
\right)
}

\newcommand{\FlaThreeByOneBNoPar}[3]{
\begin{array}{c}
#1 \\ \whline
#2 \\ \hline
#3
\end{array}
}

\newcommand{\FlaThreeByOneSingleLine}[3]{
\left(
\begin{array}{c}
#1 \\ \hline
#2 \\ \hline
#3
\end{array}
\right)
}

\newcommand{\FlaThreeByOneNoLine}[3]{
\left(
\begin{array}{c}
#1 \\
#2 \\
#3
\end{array}
\right)
}

% Various key words

% The following is a typical use of
% \FlaPartition:
%
% \FlaPartition {
%    $ A \rightarrow \FlaTwoByTwo{ A_{TL} }{ A_{TR} }
%                                { A_{BL} }{ A_{BR} } $
% }
% {
%    where $ A_{TL} $ is $ 0 \times 0 $
% }
%
% Creates something like
% Partition A -> / A_TL || A_TR \
%                | =====  ===== |
%                \ A_BL || A_BR /
% where A_TL is 0 x 0
%

\newcommand{\FlaPartition}[2]{
\ifthenelse{\boolean{IsWide}}{{\bf partition } \hspace{-1em} #1 \hspace{-1em} #2}
{{\bf partition } \+ \\ #1 \+ \\ #2 \- \-}
}

% The following is a typical use of
% \FlaRepartition:
%
% \FlaRepartition{
% $
% \FlaTwoByTwo{ A_{TL} }{ A_{TR} }
%             { A_{BL} }{ A_{BR} } \rightarrow
% \FlaThreeByThreeBR{ A_{00} }{ A_{01} }{ A_{02} }
%                   { A_{10} }{ A_{11} }{ A_{12} }
%                   { A_{20} }{ A_{21} }{ A_{22} }
% $
% }
% {
%    \FlaWhere{$ A_{11} $ is $ b \times b $}
%  }
%
% Creates something like
% Repartition
%   / A_TL || A_TR \    / A_00 || A_01 | A_02 \
%   | =====  ===== | -> | =====  ====== ===== |
%   \ A_BL || A_BR /    | A_10 || A_11 | A_12 |
%                       | -----  ------ ----- |
%                       \ A_20 || A_21 | A_22 /
% where A_11 is b x b
%

\newcommand{\FlaRepartition}[2]{
\ifthenelse{\boolean{IsWide}}{{\bf repartition } \hspace{-1em} #1 \hspace{-1em} #2}
{{\bf repartition } \+ \\ #1 \+ \\ #2 \- \-}
}

% The following is a typical use of
% \FlaContinue:
%
% \FlaContinue{
% $
%    \FlaTwoByTwo{ A_{TL} }{ A_{TR} }
%                { A_{BL} }{ A_{BR} } \leftarrow
%    \FlaThreeByThreeTL{ A_{00} }{ A_{01} }{ A_{02} }
%                      { A_{10} }{ A_{11} }{ A_{12} }
%                      { A_{20} }{ A_{21} }{ A_{22} }
% $
% }
%
% Creates something like
% Continue with
%   / A_TL || A_TR \    / A_00 | A_01 || A_02 \
%   | =====  ===== | <- | ----- ------  ----- |
%   \ A_BL || A_BR /    | A_10 | A_11 || A_12 |
%                       | ===== ======  ===== |
%                       \ A_20 | A_21 || A_22 /

\newcommand{\FlaStartCompute}{%
\setlength{\unitlength}{3in}%
\begin{picture}(2,0.01)
\put(0,0){\line(1,0){2}}
\put(0,0.01){\line(1,0){2}}
\end{picture}%
}

\newcommand{\FlaEndCompute}{%
\noindent%
\setlength{\unitlength}{3in}%
\begin{picture}(2,0.01)
\put(0,0){\line(1,0){2}}
\put(0,0.01){\line(1,0){2}}
\end{picture}%
}

\newcommand{\FlaStartComputeShort}{
\setlength{\unitlength}{1.30in}
\begin{picture}(3,0.01)
\put(0,0){\line(1,0){3}}
\put(0,0.01){\line(1,0){3}}
\end{picture}
}

\newcommand{\FlaStartComputeShorter}{
{\color{red}
\setlength{\unitlength}{0.5in}
\begin{picture}(3,0.01)
\put(0,0){\line(1,0){3}}
\put(0,0.01){\line(1,0){3}}
\end{picture}
}
}

\newcommand{\FlaEndComputeShort}{
\setlength{\unitlength}{1.30in}
\begin{picture}(3,0.01)
\put(0,0){\line(1,0){3}}
\put(0,0.01){\line(1,0){3}}
\end{picture}
}

\newcommand{\FlaEndComputeShorter}{
{\color{red}
\setlength{\unitlength}{0.5in}
\begin{picture}(3,0.01)
\put(0,0){\line(1,0){3}}
\put(0,0.01){\line(1,0){3}}
\end{picture}
}
}

\newcommand{\FlaUpLo}[2]{
{#1} \backslash {#2}
}

\newcommand{\FlaInverse}[1]{
{ #1 }^{-1}
}

\newcommand{\Square}{ \mbox{Square} }
\newcommand{\Symm}{ \mbox{Symm} }
\newcommand{\SameSize}{ \mbox{SameSize} }
\newcommand{\RowDim}{\mbox{RowDim}}
\newcommand{\ColDim}{\mbox{ColDim}}
\newcommand{\LowTr}{\mbox{LowTr}}
\newcommand{\UpTr}{\mbox{UpTr}}
\newcommand{\UpperTr}{\mbox{UpTr}}
\newcommand{\UppTr}{\mbox{UpTr}}
\newcommand{\operation}{ [ D, E, F, \ldots ] \becomes {\rm op}( A, B, C, D, \ldots ) }
\newcommand{\routinename}{ [ D, E, F, \ldots ] \becomes {\rm op}( A, B, C, D, \ldots ) }
\newcommand{\routinecost}{ X }
\newcommand{\precondition}{ Q }
\newcommand{\postcondition}{ R }
\newcommand{\invariant}{ P }
\newcommand{\costinv}{ \  }
\newcommand{\costbefore}{ \  }
\newcommand{\costafter}{ \  }
\newcommand{\updatecost}{ \  }
\newcommand{\guard}{ R }
\newcommand{\partitionings}{
\begin{minipage}{3in}
$ S_I $
\end{minipage}
}
\newcommand{\initialize}{}

\newcommand{\partitionsizes}{ \hspace{ 3.25in} }

\newcommand{\blocksize}{1}

\newcommand{\repartitionings}{
\begin{minipage}[t]{3in}
\ \\
\ \\
\ \\
\end{minipage}
}

\newcommand{\repartitionsizes}{ \hspace{ 3.25in} }
\newcommand{\moveboundaries}{
\begin{minipage}[t]{3in}
\ \\
\ \\
\ \\
\end{minipage}
}
\newcommand{\beforeupdate}{
$ \QBefore $
}
\newcommand{\afterupdate}{
$ \QAfter $
}
\newcommand{\update}{%
\begin{minipage}[t]{4in}
$ S_U $
\end{minipage}
}

\newcommand{\resetsteps}{
\renewcommand{\blocksize}{1}
\renewcommand{\operation}{ [ D, E, F, \ldots ] \becomes {\rm op}( A, B, C, D, \ldots ) }
\renewcommand{\routinename}{ [ D, E, F, \ldots ] \becomes {\rm op}( A, B, C, D, \ldots ) }
\renewcommand{\routinecost}{ 0 }
\renewcommand{\precondition}{ \PPre }
\renewcommand{\postcondition}{ \PPost }
\renewcommand{\invariant}{ \PInv }
\renewcommand{\costinv}{ \  }
\renewcommand{\guard}{ G }
\renewcommand{\partitionings}{ %
\begin{minipage}[t]{3in}
\ \\
\end{minipage}
}
\renewcommand{\partitionsizes}{ \hspace{ 3.25in} }
\renewcommand{\repartitionings}{%
\begin{minipage}[t]{3in}
\ \\
\end{minipage}
}
\renewcommand{\repartitionsizes}{ \hspace{ 3.25in} }
\renewcommand{\moveboundaries}{%
\begin{minipage}[t]{3in}
\ \\
\end{minipage}
}
\renewcommand{\beforeupdate}{
\QBefore
}
\renewcommand{\afterupdate}{
\QAfter
}
\renewcommand{\update}{
$ S_U $
}
}

\newenvironment{FlaBox}{
\footnotesize
\begin{framebox}
}
{
\end{framebox}
}

\newcommand{\WSoperation}{
$ \operation $
}

\newcommand{\WSprecondition}{
$ \left\{ \precondition \right\} $
}

\newcommand{\WSpostcondition}{
$ \left\{ \postcondition \right\} $
}

\newcommand{\WSinvariant}{
$ \left\{ \invariant \right\} $
}

\newcommand{\WScostinv}{
$ \Csf = \costinv $ flops
}

\newcommand{\WScostzero}{
$ \Csf = 0 $ flops
}

\newcommand{\WScostbu}{
$ \Csf = \costbefore $ flops
}

\newcommand{\WScostau}{
$ \Csf = \costafter $ flops
}

\newcommand{\WSupdatecost}{
{\bf Cost:} $ \updatecost $ flops
}

\newcommand{\WStopofloop}{
$ \left\{ \left( \invariant \right) \wedge \left( \guard \right) \right\} $
}

\newcommand{\WStopofloopnarrow}{
$ \begin{array}{r}
  \left\{ \left( \invariant \right) \right. \\
  \left. \wedge \left( \guard \right) \right\}
\end{array} $
}

\newcommand{\WSafterloop}{
$ \left\{ \left( \invariant \right) \wedge \neg \left( \guard \right) \right\} $
}

\newcommand{\WSguard}{
$ \guard $
}

\newcommand{\WSpartition}{
\begin{minipage}[t]{3in}
\begin{tabbing}
ind \= ind \= \kill
{\bf \color{blue} Partition}
\partitionings \+ \\
{\bf \color{blue} where } \hspace*{-2ex} \partitionsizes
\end{tabbing}
\end{minipage}
}

\newcommand{\WSpartitionNarrow}{
\begin{minipage}[t]{2.0in}
\begin{tabbing}
id \= id \= \kill
{\bf \color{blue} Partition}
\partitionings \+ \\
{\bf \color{blue} where }
\begin{minipage}[t]{1.75in}
\partitionsizes
\end{minipage}
\end{tabbing}
\end{minipage}
}

\newcommand{\WSinitialize}{
\initialize
}

\newcommand{\WSrepartition}{
\begin{minipage}[t]{3in}
\ifthenelse{ \equal{\blocksize}{1} }{}
{%
\ifthenelse{ \equal{\blocksize}{blank} }{~}
{{\bf Determine block size $ \blocksize $}} \\
}
{\bf \color{blue} Repartition}
\begin{tabbing}
in \= in \= \+ \kill
\repartitionings \+ \\
{\bf \color{blue} where } \hspace*{-2ex} \repartitionsizes
\end{tabbing}
\end{minipage}
}

\newcommand{\WSrepartitionNarrow}{
\begin{minipage}[t]{2.05in}
%%% \ifthenelse{ \equal{\blocksize}{1} }{}
%%% {%
%%% \ifthenelse{ \equal{\blocksize}{blank} }{~}
%%% {{\bf \color{blue} Determine block size $ \blocksize $}} \\
%%% }
{\bf \color{blue} Repartition}
\begin{tabbing}
i \= i \= \+ \kill
\repartitionings 
%%% \+ \\
%% {\bf \color{blue} where }
%%% \begin{minipage}[t]{1.5in}
%%% \repartitionsizes
%%% \end{minipage}
\end{tabbing}
\end{minipage}
}

\newcommand{\WSmoveboundary}{
\begin{minipage}[t]{4in}
{\bf \color{blue} Continue with}
\begin{tabbing}
ind \= \+ \kill
\moveboundaries
\end{tabbing}
\end{minipage}
}

\newcommand{\WSmoveboundaryNarrow}{
\begin{minipage}[t]{2.05in}
{\bf \color{blue} Continue with}
\begin{tabbing}
i \= \+ \kill
\moveboundaries
\end{tabbing}
\end{minipage}
}

\newcommand{\WSbeforeupdate}{
$ \left\{ \beforeupdate \right\} $
}

\newcommand{\WSafterupdate}{
$ \left\{ \afterupdate \right\} $
}

\newcommand{\WSupdate}{
\update
}

\newcommand{\worksheet}{
\begin{center}
\begin{tabular}{| c I l |} \hline
\footnotesize {\bf Step} &
{\bf \color{blue} Annotated Algorithm:} $\operation$
\\ \whline
\rowcolor[gray]{0.93}
1a &
\WSprecondition \\ \hline
4 &
\WSpartition \\ \hline
\rowcolor[gray]{0.93}
2 &
\WSinvariant \\ \hline
3 &
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\ \hline
\rowcolor[gray]{0.93}
2,3 &
\ \hspace{0.15in} \WStopofloop \\ \hline
5a &
\ \hspace{0.15in}
\WSrepartition
\\ \hline
\rowcolor[gray]{0.93}
6 &
\ \hspace{0.15in} \WSbeforeupdate \\ \hline
8 & \ \hspace{0.15in} \WSupdate \\ \hline
5b &
\ \hspace{0.15in}
\WSmoveboundary
\\ \hline
\rowcolor[gray]{0.93}
7 &
\ \hspace{0.15in} \WSafterupdate \\ \hline
\rowcolor[gray]{0.93}
2 &
\ \hspace{0.15in} \WSinvariant \\ \hline
& {\bf \color{blue} endwhile} \\ \hline
\rowcolor[gray]{0.93}
2,3 &
\WSafterloop \\ \hline
\rowcolor[gray]{0.93}
1b &
\WSpostcondition \\ \hline
\end{tabular}
\end{center}
}

\newcommand{\worksheetnarrow}{
\begin{center}
\begin{tabular}{| c I l |} \hline
\footnotesize {\bf Step} &
{\bf \color{blue} Annotated Algorithm:} $\routinename$
\\ \whline
\rowcolor[gray]{0.93}
1a &
\WSprecondition \\ \hline
4 &
\WSpartition \\ \hline
\rowcolor[gray]{0.93}
2 &
\WSinvariant \\ \hline
3 &
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\ \hline
\rowcolor[gray]{0.93}
2,3 &
\ \hspace{0.15in} \WStopofloopnarrow \\ \hline
5a &
\ \hspace{0.15in}
\WSrepartition
\\ \hline
\rowcolor[gray]{0.93}
6 &
\ \hspace{0.15in} \WSbeforeupdate \\ \hline
8 & \ \hspace{0.15in} \WSupdate \\ \hline
5b &
\ \hspace{0.15in}
\WSmoveboundary
\\ \hline
\rowcolor[gray]{0.93}
7 &
\ \hspace{0.15in} \WSafterupdate \\ \hline
\rowcolor[gray]{0.93}
2 &
\ \hspace{0.15in} \WSinvariant \\ \hline
& {\bf \color{blue} endwhile} \\ \hline
\rowcolor[gray]{0.93}
2,3 &
\WSafterloop \\ \hline
\rowcolor[gray]{0.93}
1b &
\WSpostcondition \\ \hline
\end{tabular}
\end{center}
}

\newcommand{\worksheetwithcost}{
\begin{center}
\begin{tabular}{| c I l  r | } \hline
\footnotesize {\bf Step} &
\multicolumn{2}{l|}
{{\bf Cost Analysis:} $\routinename$}
\\ \whline
\rowcolor[gray]{0.93}
1a &
% \WSprecondition
& \WScostzero \\ \hline
4 & \multicolumn{2}{l|}{
\WSpartition} \\ \hline
\rowcolor[gray]{0.93}
2 &
% \WSinvariant
& \WScostinv \\ \hline
3 & \multicolumn{2}{l|}{
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} }\\ \hline
\rowcolor[gray]{0.93}
2,3 &
% \ \hspace{0.15in} \WStopofloop
& \WScostinv \\ \hline
5a & \multicolumn{2}{l|}{
\ \hspace{0.15in}
\WSrepartition}
\\ \hline
\rowcolor[gray]{0.93}
6 &
% \ \hspace{0.15in} \WSbeforeupdate
&
\WScostbu
\\ \hline
8 &
\hspace{0.15in} \WSupdate
&
\WSupdatecost \\ \hline
5b &\multicolumn{2}{l|}{
\ \hspace{0.15in}
\WSmoveboundary}
\\ \hline
\rowcolor[gray]{0.93}
7 &
% \ \hspace{0.15in} \WSafterupdate
&
\WScostau
\\ \hline
\rowcolor[gray]{0.93}
2 &
% \ \hspace{0.15in} \WSinvariant
&
\WScostinv \\ \hline
& \multicolumn{2}{l|}{{\bf \color{blue} endwhile}} \\ \hline
\rowcolor[gray]{0.93}
2,3 &
% \WSafterloop
&
\WScostinv
\\ \hline
\rowcolor[gray]{0.93}
1b &
% \WSpostcondition
\multicolumn{2}{r|}
{{\bf Total Cost:} $ \routinecost $ flops}
\\ \hline
\end{tabular}
\end{center}
}

\newcommand{\worksheetnosteps}{
\begin{center}
\begin{tabular}{| l |} \hline
{ \color{blue} Annotated Algorithm: } \WSoperation \\ \whline
\rowcolor[gray]{0.93}
\WSprecondition \\ \hline
\WSpartition \\ \hline
\rowcolor[gray]{0.93}
\WSinvariant \\ \hline
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\ \hline
\rowcolor[gray]{0.93}
\ \hspace{0.15in} \WStopofloop \\ \hline
\ \hspace{0.15in}
\WSrepartition
\\ \hline
\rowcolor[gray]{0.93}
\ \hspace{0.15in} \WSbeforeupdate \\ \hline
\hspace{0.15in} \WSupdate \\ \hline
\ \hspace{0.15in}
\WSmoveboundary
\\ \hline
\rowcolor[gray]{0.93}
\ \hspace{0.15in} \WSafterupdate \\ \hline
\rowcolor[gray]{0.93}
\ \hspace{0.15in} \WSinvariant \\ \hline
{\bf \color{blue} endwhile} \\ \hline
\rowcolor[gray]{0.93}
\WSafterloop \\ \hline
\rowcolor[gray]{0.93}
\WSpostcondition \\ \hline
\end{tabular}
\end{center}
}

\newcommand{\worksheetupdate}{
\begin{center}
\begin{tabular}{| c I l |} \hline
\footnotesize Step & { \color{blue} Annotated Algorithm: } \WSoperation \\ \whline
3 &
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\ \hline
2,3 &
\ \hspace{0.15in} \WStopofloop \\ \hline
5a &
\ \hspace{0.15in}
\WSrepartition
\\ \hline
6 &
\ \hspace{0.15in} \WSbeforeupdate \\ \hline
8 & \hspace{0.15in} \WSupdate \\ \hline
5b &
\ \hspace{0.15in}
\WSmoveboundary
\\ \hline
7 &
\ \hspace{0.15in} \WSafterupdate \\ \hline
2 &
\ \hspace{0.15in} \WSinvariant \\ \hline
& {\bf \color{blue} endwhile} \\ \hline
\end{tabular}
\end{center}
}

\newcommand{\FlaAlgorithm}{
\begin{center}
\begin{tabular}{|l |} \hline
{\bf \color{blue} Algorithm:} $\routinename$
\\ \whline
{\WSpartition} \\[0.3in]
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\
\ \hspace{0.15in} \WSrepartition \\
\color{red} {\hspace{0.0in} \FlaStartCompute} \\
{\hspace{0.0in} \WSupdate} \\
\color{red} {\hspace{0.0in} \FlaEndCompute} \\
{\ \hspace{0.15in} \WSmoveboundary} \\
{{\bf \color{blue} endwhile}} \\ \hline
\end{tabular}
\end{center}
}


\newcommand{\FlaAlgorithmWithInit}{
\begin{center}
\begin{tabular}{|l |} \hline
{\bf \color{blue} Algorithm:} $\routinename$
\\ \whline
{\WSpartition} \\[0.3in]
\WSinitialize \\
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\
\ \hspace{0.15in} \WSrepartition \\
\color{red} {\hspace{0.0in} \FlaStartCompute} \\
{\hspace{0.0in} \WSupdate} \\
\color{red} {\hspace{0.0in} \FlaEndCompute} \\
{\ \hspace{0.15in} \WSmoveboundary} \\
{{\bf \color{blue} endwhile}} \\ \hline
\end{tabular}
\end{center}
}


\newcommand{\FlaAlgorithmNarrow}{
\begin{center}
\begin{tabular}{|l |} \hline
{\bf \color{blue} Algorithm:} $\routinename$
\\ \whline
\color{black} \WSpartitionNarrow \\
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\[-0.1in]
\ \hspace{0.0in} \color{black} \WSrepartitionNarrow \\[-0.1in]
{\hspace{0.0in} \FlaStartComputeShorter} \\
{\hspace{0.0in} \color{black} \WSupdate} \\[-0.1in]
{\hspace{0.0in} \FlaEndComputeShorter} \\[-0.1in]
{\ \hspace{0.0in} \color{black} \WSmoveboundaryNarrow} \\
{{\bf \color{blue} endwhile}} \\ \hline
\end{tabular}
\end{center}
}

\newcommand{\FlaAlgorithmNarrowInit}{
\begin{center}
\begin{tabular}{|l |} \hline
{\bf \color{blue} Algorithm:} $\routinename$
\\ \whline
\color{red} \WSpartitionNarrow \\
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\[-0.1in]
\ \hspace{0.0in} \color{black} \WSrepartitionNarrow \\[-0.1in]
{\hspace{0.0in} \FlaStartComputeShorter} \\
{\hspace{0.0in} \color{black} \WSupdate} \\[-0.1in]
{\hspace{0.0in} \FlaEndComputeShorter} \\[-0.1in]
{\ \hspace{0.0in} \color{black} \WSmoveboundaryNarrow} \\
{{\bf \color{blue} endwhile}} \\ \hline
\end{tabular}
\end{center}
}

\newcommand{\FlaAlgorithmNarrowRepart}{
\begin{center}
\begin{tabular}{|l |} \hline
{\bf \color{blue} Algorithm:} $\routinename$
\\ \whline
\color{black} \WSpartitionNarrow \\
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\[-0.1in]
\ \hspace{0.0in} \color{red} \WSrepartitionNarrow \\[-0.1in]
{\hspace{0.0in} \FlaStartComputeShorter} \\
{\hspace{0.0in} \color{black} \WSupdate} \\[-0.1in]
{\hspace{0.0in} \FlaEndComputeShorter} \\[-0.1in]
{\ \hspace{0.0in} \color{black} \WSmoveboundaryNarrow} \\
{{\bf \color{blue} endwhile}} \\ \hline
\end{tabular}
\end{center}
}

\newcommand{\FlaAlgorithmNarrowUpdate}{
\begin{center}
\begin{tabular}{|l |} \hline
{\bf \color{blue} Algorithm:} $\routinename$
\\ \whline
\color{black} \WSpartitionNarrow \\
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\[-0.1in]
\ \hspace{0.0in} \color{black} \WSrepartitionNarrow \\[-0.1in]
{\hspace{0.0in} \FlaStartComputeShorter} \\
{\hspace{0.0in} \color{red} \WSupdate} \\[-0.1in]
{\hspace{0.0in} \FlaEndComputeShorter} \\[-0.1in]
{\ \hspace{0.0in} \color{black} \WSmoveboundaryNarrow} \\
{{\bf \color{blue} endwhile}} \\ \hline
\end{tabular}
\end{center}
}

\newcommand{\FlaAlgorithmNarrowMove}{
\begin{center}
\begin{tabular}{|l |} \hline
{\bf \color{blue} Algorithm:} $\routinename$
\\ \whline
\color{black} \WSpartitionNarrow \\
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\[-0.1in]
\ \hspace{0.0in} \color{black} \WSrepartitionNarrow \\[-0.1in]
{\hspace{0.0in} \FlaStartComputeShorter} \\
{\hspace{0.0in} \color{black} \WSupdate} \\[-0.1in]
{\hspace{0.0in} \FlaEndComputeShorter} \\[-0.1in]
{\ \hspace{0.0in} \color{red} \WSmoveboundaryNarrow} \\
{{\bf \color{blue} endwhile}} \\ \hline
\end{tabular}
\end{center}
}


\newcommand{\FlaAlgorithmNarrowWithInit}{
\begin{center}
\begin{tabular}{|l |} \hline
{\bf \color{blue} Algorithm:} $\routinename$
\\ \whline
\WSpartitionNarrow \\
\WSinitialize \\
{\bf \color{blue} while} \WSguard { \bf \color{blue} do} \\[-0.1in]
\ \hspace{0.0in} \WSrepartitionNarrow \\[-0.1in]
{\hspace{0.0in} \FlaStartComputeShorter} \\
{\hspace{0.0in} \WSupdate} \\[-0.1in]
{\hspace{0.0in} \FlaEndComputeShorter} \\[-0.1in]
{\ \hspace{0.0in} \WSmoveboundaryNarrow} \\
{{\bf \color{blue} endwhile}} \\ \hline
\end{tabular}
\end{center}
}



\newcommand{ \PPre }{ P_{\it pre} }
\newcommand{ \PPost }{ P_{\it post} }
\newcommand{ \PInv }{ P_{\it inv} }
\newcommand{ \PInvone }{ P_{\it inv-1} }
\newcommand{ \PInvtwo }{ P_{\it inv-2} }
\newcommand{ \QBefore }{ P_{\it before} }
\newcommand{ \QAfter }{ P_{\it after} }
\newcommand{ \Qbefore }{ P_{\it before} }
\newcommand{ \Qafter }{ P_{\it after} }
\newcommand{ \PCons }{ P_{\it cons} }
\newcommand{ \PCost }{ P_{\it cost} }
\newcommand{ \PStr }{ P_{\it struct} }
\newcommand{ \Csf }{ C_{\it sf} }

\newcommand{\becomes}{:=}



